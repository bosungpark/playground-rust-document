fn 이터레이터로_일련의_아이템들_처리하기() {
    println!(
        "
        러스트의 이터레이터는 lazy하게 동작한다.
        이터레이터의 동작 방식에 대해 살펴보자.

        Iterator 트레이트와 next 메서드
        -

        pub trait Iterator {
            type Item;
        
            fn next(&mut self) -> Option<Self::Item>;
        
            // 기본 구현이 있는 메서드는 생략했습니다
        }

        모든 이터레이터는 표준 라이브러리에 정의된 Iterator라는 이름의 트레이트를 구현한다.
        Iterator 트레이트를 구현하려면 Item 타입도 함께 정의되어야 하며, 이 Item 타입이 next 메서드의 반환 타입으로 사용된다.
        또 Iterator 트레이트는 구현할 때 next의 정의를 요구한다.
        (Iterator 트레이트의 일부 메서드 정의에서 next를 사용하기 때문)

        next 메서드 호출은 이터레이터 내부의 상태를 변경하여 이터레이터가 현재 시퀀스의 어디에 있는지 추적한다.
        즉, 코드의 실행은 이터레이터를 소비하는 것이다.

        ㄴ> 이 소비 여부는 이터레이터를 반복해서 실행하는 지 여부와도 관련이 있다.

        그래서 만일 next에 대한 호출을 하는 경우라면 이터레이터를 가변으로 선언할 필요가 있다.
        단, for 루프 등을 사용할 때에는 이터레이터를 가변으로 만들 필요는 없는데, 루프가 이터레이터의 소유권을 가지고 내부적으로 가변으로 만들어주기 때문이다.
        "
    )
}

fn 반복자를_소비하는_메서드() {
    println!(
        "
        next를 호출하는 메서드들을 소비 어댑터(consuming adaptor) 라고 한다. 
        이는 next를 호출하면 반복자를 소비하기 때문이다.

        예:

        이터레이터.sum();
        "
    )
}

fn 다른_반복자를_생성하는_메서드() {
    println!(
        "
        반복자 어댑터 (iterator adaptor)는 반복자를 소비하는 대신, 원본의 일부를 바꾸어 다른 반복자를 반환한다.

        예:

        이터레이터.map(|x| x + 1);
        "
    )
}
