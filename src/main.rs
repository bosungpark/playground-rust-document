fn main() {}

fn 매크로와_함수의_차이() {
    // 매크로의 구성은 아래와 같다.

    // 1. 선언적 매크로
    // 2. 절차적 매크로
    //  2-1. 커스텀 #[derive] 매크로
    //  2-2. 속성형 매크로
    //  2-3. 함수형 매크로

    // 매크로는 다른 코드를 작성하는 코드를 작성하는 방법으로 메타프로그래밍이라고 한다.
    // 매크로에는 함수에는 없는 몇 가지 추가 기능이 있다.

    // 매크로는 가변적인 수의 매개변수를 사용할 수 있다.
    // (예: println!("hello {}", name), 함수가 시그니처에 정의하는 것과 차이)

    // 매크로는 컴파일러가 코드의 의미를 해석하기 전에 확장되기 때문에,
    // 매크로는 주어진 타입에 대한 트레이트를 구현할 수 있다. (런타임에 호출되는 함수와 차이)

    // 단, 일반적으로 매크로는 함수보다 정의가 복잡하고 유지보수가 더 어려운 면이 있다.
    // 또, 어디서나 정의하고 어디서나 호출할 수 있는 함수와 달리 매크로의 경우 정의하거나 파일에서 호출하기 전에 매크로를 스코프로 가져와야 한다
}

fn 선언적_매크로() {
    // 선언적 매크로는 특정 코드와 연관된 패턴과 값을 비교하여, 코드를 다른 코드로 대체하는 역할을 한다.
    // ㄴ> 말 그대로 벡터처럼 선언을 해서 쓰는 경우인듯,,

    // 벡터 매크로 정의의 예시:
    let v: Vec<u32> = vec![1, 2, 3];

    // #[macro_export]
    // macro_rules! vec {
    // ( $( $x:expr ),* ) => {
    //     {
    //         let mut temp_vec = Vec::new();
    //         $(
    //             temp_vec.push($x);
    //         )*
    //         temp_vec
    //     }
    // };
    // }
}

fn 절차적_매크로() {
    // 절차적 매크로는 선언적인 경우보다는 더 함수처럼 작동한다.
    // 어떤 코드를 입력으로 받아서 해당 코드에 대해 작업을 수행한 다음, 어떤 코드를 출력으로 생성한다.
    // (단, 특별한 크레이트 타입을 가진 자신만의 크레이트에 있어야한다.)

    // 1. 커스텀 derive 매크로

    // 2. 속성형 매크로
    // derive는 구조체와 열거형에만 작동하고, 속성에 대한 코드를 생성하는 대신 새 속성을 생성한다.
    // 그 외에, 속성형 매크로는 커스텀 파생 매크로와 동일한 방식으로 작동한다.

    // 3. 함수형 매크로
    // 함수 호출 처럼 보이지만, 임의의 갯수를 가지는 인수를 사용할 수 있다. (sql 구문을 확인하는 매크로)

    // ㄴ> 내가 이해하기로는 절차적 매크로는 무언가 인수를 받아 사용하는 매크로이고
    // ㄴ> 세부적인 특징을 분류하면 세 가지로 나눌수 있다! 인듯,,
}
