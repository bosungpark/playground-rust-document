// 러스트 열거형의 가장 중요한 특징은 반드시 하나에 매칭이 된다는 것이다
// 구조체는 and  조건으로 나열될 수 있으나, 열거형은 걸리는 정답이 하나라는 특성을 가진다.
// 이 점을 잘 이용하면 match 절 등에서 예외없는 검증이 가능하다.

enum 열거형 {
    배리언트1(String),
    배리언트2,
}

impl 열거형 {
    fn 메서드_호출(&self) {
        // ...
    }
}

enum 열겨형의_배리언트가_가질_수_있는_다양한_예시 {
    Quit,
    Move { x: i32, y: i32 },  // struct 키워드를 사용하지 않는다
    Write(String),
    ChangeColor(i32, i32, i32),
}


fn 열거형_정의하기() {
    // 열거형은 어떤 값이 여러 개의 가능한 값의 집합 중 하나라는 것을 나타내는 방법을 제공
    // 열거형을 정의할 때의 식별자로 네임스페이스가 만들어져서, 각 배리언트 앞에 이중 콜론(::)을 붙여야 한다
    
    let 1번 = 열거형::배리언트1(String::from("안녕"));
    1번.메서드_호출();    

}

enum Option<T> {
    None,
    Some(T),
}


fn Option_열거형이_널_값보다_좋은_점들() {
    // Option 타입은 값이 있거나 없을 수 있는 경우 사용
    // 러스트는 다른 언어들에서 흔하게 볼 수 있는 널 (null) 개념이 없다
    // 러스트에는 널이 없지만, 값의 존재 혹은 부재의 개념을 표현할 수 있는 열거형이 있다
    //  그 열거형이 바로 Option<T>

    // Option<T>와 T(T는 어떤 타입이던 될 수 있음)이 다른 타입이기 때문에, 컴파일러는 Option<T> 값을 명백하게 유효한 값처럼 사용하지 못한다
    // 바꿔 말하면, T에 대한 연산을 수행하기 전에 Option<T>를 T로 변환해야 한다

    
}
