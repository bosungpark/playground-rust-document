fn Box를_사용하여_힙에_있는_데이터_가리키기() {
    println!(
        "
        박스는 스마트 포인터로 스택이 아니라 힙에 데이터를 저장할 수 있도록 해준다.
        오버헤드는 없다.
        스택에는 힙 데이터를 가리키는 포인터만 남는다.

        사용예시:

        1. 컴파일 타임에는 크기를 알 수 없는 타입을, 정확한 크기를 요구하는 컨텍스트에서 그 타입의 값을 사용하고 싶을 때
        2. 커다란 데이터의 소유권을 옮기고 싶지만, 동시에 데이터를 복사하고 싶지는 않을때
        3. 어떤 값을 소유하고, 구체화된 타입보다는 특정 트레이트를 구현한 타입이라는 점만 신경 쓰고 싶을 때
        "
    )
}

fn Box를_사용하여_힙에_데이터_저장하기() {
    // 5는 힙에 할당
    // 하지만 스택에 있는 것처럼 접근 가능
    let 박스 = Box::new("안녕하세요 박스입니다.");

    println!("박스 = {}", 박스);
    // 스코프를 벗어나면 Box와 데이터에 모두 할당 해제
}

fn Box로_재귀적_타입_가능하게_하기() {
    println!(
        "
        재귀적 타입은 자신 안에 동일한 타입의 또 다른 값을 담을 수 있다.
        러스트는 컴파일 타임에 타입이 차지하는 공간을 알아야 하기 때문에 재귀적 타입은 문제를 일으킨다.

        박스는 크기를 알 수 있으므로, 재귀적 타입의 정의에 박스를 집어넣으면 재귀적 타입을 사용할 수 있다. 
        "
    );

    // 1. 사용 불가능한 재귀적 타입 예시

    // enum List {
    //     Cons(i32, List),
    //     Nil,
    // }

    // 재귀적 타입은 컴파일 불가! recursive type `List` has infinite size
    // ㄴ> enum 파트를 복습하면 값을 할당하기 위해 필요한 공간의 양을 결정할 때,
    // ㄴ> 러스트는 각 배리언트들의 내부를 보면서 어떤 배리언트가 가장 많은 공간을 필요로 하는지를 기준으로 한다.

    // 2. 사용 가능한 재귀적 타입 예시

    // enum List {
    //     Cons(i32, Box<List>),
    //     Nil,
    // }

    let 재귀_리스트 = Cons(1, Box::new(Cons(2, Box::new(Nil))));
    // ㄴ> 개념적으로는 여전히 다른 리스트들을 담은 리스트로 만들어진 리스트지만,
    // ㄴ> 구현은 아이템을 다른 것 안쪽에 넣는 것이 아니라 그다음 위치에 놓는 형태에 더 가깝다.
    // ㄴ> 즉, 무한한 재귀의 연결은 Box를 사용하는 순간 끊긴다.
}

enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};
