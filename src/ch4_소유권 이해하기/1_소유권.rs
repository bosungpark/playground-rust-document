// fn main() {
//     소유권이_뭔가요();
//     스택_영역과_힙_영역();
//     소유권_규칙();
//     보다_복잡한_예시();
//     소유권과_함수();

//     // TODO: 다음 장에서는 소유권의 번거로움을 해소하기 위한 레퍼런스 개념이 이어짐
// }

fn 소유권이_뭔가요() {
    // 러스트가 "메모리 관리"를 위해 소유권 (ownership) 이라는 시스템을 만들고,
    // 컴파일러가 컴파일 중에 검사할 여러 규칙을 정해 메모리를 관리하는 방식.
    // 이 규칙 중 하나라도 위반하면 프로그램은 컴파일되지 않는다.
    // 소유권의 어떠한 특성도 프로그램 실행 속도를 느리게 하지 않는다.
}

fn 스택_영역과_힙_영역() {
    // 러스트 같은 시스템 프로그래밍 언어에서는 값을 스택에 저장하느냐 힙에 저장하느냐가 중요하다.
    // 코드 어느 부분에서 힙의 데이터를 사용하는지 추적하고,
    // 힙에서 중복되는 데이터를 최소화하고,
    // 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 등의 작업은 모두 소유권과 관련되어 있다.
    // 소유권의 주요 목표는 힙 데이터의 관리이다.

    // 1. 스택
    // 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 한다.
    // 메모리 할당자가 새로운 데이터를 저장할 공간을 찾을 필요가 없다.
    // 스택이 빠르고 효율적인 이유 중 하나.
    // 스택의 메모리 할당과 해제가 매우 빠르고 데이터가 붙어있기 때문에, 스택을 사용하면 메모리 접근과 관리가 효율적
    // 그러나 스택은 제한된 용량을 가지고 있고, 스택이 너무 커지면 스택 오버플로우(Stack Overflow)가 발생할 수 있다.
    // 컴파일 타임에 크기를 알 수 없거나, 크기가 변경될 수 있는 데이터는 스택 대신 힙에 저장되어야 한다.

    // 2. 힙
    // 데이터를 힙에 넣을 때, 메모리 할당자는 커다란 힙 영역 안에서 어떤 빈 지점을 찾고,
    // 이 지점은 사용 중이라고 표시한 뒤 해당 지점을 가리키는 포인터(pointer)를 반환
    // 이 과정을 힙 공간 할당 (allocating on the heap)이라고 한다.
    // 포인터는 크기가 정해져 있어 스택에 저장할 수 있으나,
    // 포인터가 가리키는 실제 데이터를 사용할 때는 포인터를 참조해 해당 포인터가 가리키는 위치로 이동하는 과정을 거쳐야 한다.
    // 힙 영역은 이 서로 멀리 떨어진 데이터를 메모리에서 찾는 과정으로 인해 느리다.
}

fn 소유권_규칙() {
    // 1. 기본 컨셉
    // 러스트에서, 각각의 값은 소유자 (owner) 가 정해져 있다.
    // 한 값의 소유자는 동시에 여럿 존재할 수 없다.
    // 소유자가 스코프 밖으로 벗어날 때, 값은 버려진다

    {
        // --- 여기부터 유효 ---
        let _변수 = "변수";
    } // --- 여기까지 유효 ---

    // 2. 메모리와 할당
    // 문자열 리터럴은 컴파일 타임에 내용을 알 수 있으므로, 텍스트가 최종 실행파일에 하드코딩된다.
    // 반면 String 타입은 힙에 메모리를 할당하는 방식을 사용하기 때문에 텍스트 내용 및 크기를 변경할 수 있다.

    // - 실행 중 메모리 할당자로부터 메모리를 요청
    // - String 사용을 마쳤을 때 메모리를 해제할 (즉, 할당자에게 메모리를 반납할) 방법이 필요
    //      ㄴ> 러스트에서는 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제하는 방식을 사용한다.

    {
        // --- 여기부터 유효 ---
        let _힙에_저장될_변수 = String::from("힙에 저장될 변수라네");
        // ! drop 함수 호출 !
    } // --- 여기까지 유효 ---
}

fn 보다_복잡한_예시() {
    // 1. 변수와 데이터 간 상호작용 방식: 이동

    let _스택에_저장될_변수 = "스택에 저장될 변수라네";
    let _스택에_저장될_변수를_복사한_변수 = _스택에_저장될_변수;

    let _힙에_저장될_변수 = String::from(
        "
        힙에 저장될 변수라네 
        데이터는 힙에 저장되지만 포인터 길이 변수 데이터는 스택에 저장된다네 
        다른 변수에 할당 할 때에는 스택에 저장된 포인터 길이 변수값이 복사되고 
        힙에 저장된 데이터는 복사되지 않는다네
        ",
    );
    let _힙에_저장될_변수를_이동한_변수 = _힙에_저장될_변수;

    // ㄴ> 그런데 이와 같이 두 변수의 포인터(스택)가 하나의 데이터(힙)를 가리킨다면 어떻게 될까?
    // ㄴ> 각각 메모리를 해제한다면 중복해제이다.
    // ㄴ> 러스트에서는 'let _힙에_저장될_변수를_이동한_변수 = _힙에_저장될_변수;' 구문 아래로는
    // ㄴ> 더이상 _힙에_저장될_변수가 유효하지 않다고 판단한다.

    // println!("{_힙에_저장될_변수}"); // error[E0382]: borrow of moved value: `_힙에_저장될_변수`

    // ㄴ> 러스트에서는 앝은 복사와는 조금 다르게 변수 자체를 무효화하기 때문에, move라는 표현을 사용한다.
    // ㄴ> 또 추가로, 러스트는 절대 자동으로 깊은 복사로 데이터를 복사하는 일이 없다.

    // 2. 변수와 데이터 간 상호작용 방식: 클론
    // String의 힙 데이터까지 깊이 복사하고 싶을 땐 clone이라는 공용 메서드를 사용할 수 있다.

    let _힙에_저장될_변수 = String::from(
        "
        힙에 저장될 변수라네 
        데이터는 힙에 저장되지만 포인터 길이 변수 데이터는 스택에 저장된다네 
        다른 변수에 할당 할 때에는 스택에 저장된 포인터 길이 변수값이 복사되고 
        힙에 저장된 데이터는 복사되지 않는다네

        하지만 클론을 사용하면 힙 영역에 있는 데이터를 모두 들고 올 수 있다네
        ",
    );
    let _힙에_저장될_변수를_클론한_변수 = _힙에_저장될_변수.clone();
    println!("{_힙에_저장될_변수를_클론한_변수}"); // 힙에 저장될 변수라네... 이하 생략...

    // ㄴ> 비교적 무거운 작업임을 .clone()으로 명시하는 느낌도 있다고 한다.

    // 3. 스택에만 저장되는 데이터: 복사
    // 스택에 저장되는 값은 변수를 다른 변수에 할당하더라도 무효화를 하지 않는다.
    // 단순한 스칼라 값의 묶음은 Copy 가능하고, 할당이 필요하거나 리소스의 일종인 경우엔 불가능하다.
    // 가능한 예: 정수형 타입, bool, 부동 소수점 타입, 문자 타입, Copy 가능한 타입만으로 구성된 튜플

    // ㄴ> 그러니까 단순한 타입은 Copy 트레이트가 달려있어서 문제 없다는 이야기..?
}

fn 소유권과_함수() {
    // 예시를 통해 살펴보는 함수와 소유권은 관계
    // 함수를 사용할 때, 값을 반환할 때에도 대략 비슷하다

    // 상황은 다양할지라도, 변수의 소유권 규칙은 언제나 동일하다.
    // - 어떤 값을 다른 변수에 대입하면 값이 이동
    // - 힙에 데이터를 갖는 변수가 스코프를 벗어나면, 사전에 해당 데이터가 이동해서 소유권이 다른 변수에 이동되지 않은 이상 drop 에 의해 데이터가 제거

    // ㄴ> 대략 러스트는 함수를 호출할 때에도 소유권을 레알로 넘기고
    // ㄴ> 실행 순서에 따라 무효화가 일어날 수 있음을 인지해야 한다는 내용

    // fn main() {
    //     let s = String::from("hello");  // s가 스코프 안으로 들어옵니다

    //     takes_ownership(s);             // s의 값이 함수로 이동됩니다...
    //                                     // ... 따라서 여기서는 더 이상 유효하지 않습니다

    //     let x = 5;                      // x가 스코프 안으로 들어옵니다

    //     makes_copy(x);                  // x가 함수로 이동될 것입니다만,
    //                                     // i32는 Copy이므로 앞으로 계속 x를
    //                                     // 사용해도 좋습니다

    // } // 여기서 x가 스코프 밖으로 벗어나고 s도 그렇게 됩니다. 그러나 s의 값이 이동되었으므로
    //   // 별다른 일이 발생하지 않습니다.

    // fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어옵니다
    //     println!("{}", some_string);
    // } // 여기서 some_string이 스코프 밖으로 벗어나고 `drop`이 호출됩니다.
    //   // 메모리가 해제됩니다.

    // fn makes_copy(some_integer: i32) { // some_integer가 스코프 안으로 들어옵니다
    //     println!("{}", some_integer);
    // } // 여기서 some_integer가 스코프 밖으로 벗어납니다. 별다른 일이 발생하지 않습니다.
}
