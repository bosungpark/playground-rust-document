fn 뉴타입_패턴과_타입_별칭() {
    // 뉴타입 패턴:
    // 타입을 래핑하는 것. 아래와 같은 상황에서 유용함을 가진다.

    // 1. 값이 혼동되지 않도록 정적으로 강제하는 것
    // 2. 타입의 구현 세부 사항을 추상화

    // 타입 별칭:
    // 기존 타입에 다른 이름을 부여 (완전히 새로운 타입은 아님)
    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y); // 별칭은 기존 타입과 동일하게 취급됨 (당연히 타입 검사도 안됨)
}

fn 절대_반환하지_않는_부정_타입() {
    // 러스트에는 !라는 특수한 타입이 존재
    // 빈 타입(부정 타입)이라고 불리우는 이 타입은 함수가 절대 반환하지 않을 때(발산 함수) 반환 타입을 대신한다

    // 예를 들어 loop와 같이 끝나지 않는 경우에, loop의 반환값은 !타입이라고 생각할 수 있다,,
    loop {
        print!("and ever ");
    }
}

fn 동적_크기_타입과_Sized_트레이트() {
    // 동적 크기 타입 (크기가 지정되지 않은 타입)
    // 컴파일 서점에 특정 타입의 값에 할당할 메모리의 크기를 알 수 없으므로, 동적크기를 가지는 변수를 생성할 수는 없다.

    // 예: str
    // let s1: str = "Hello there!";
    // let s2: str = "How's it going?";

    // ㄴ> 대략 미고님이 그동안 설명해주신 내용과 동일
}
