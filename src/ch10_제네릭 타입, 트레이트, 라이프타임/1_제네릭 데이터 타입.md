제네릭을 사용하면 함수 시그니처나 구조체의 아이템에 다양한 구체적 데이터 타입을 사용할 수 있도록 정의할 수 있다. 

### 제네릭 함수 정의

제네릭 함수를 정의할 때는 함수 시그니처 내 매개변수와 반환 값의 데이터 타입 위치에 제네릭을 사용합니다. 이렇게 작성된 코드는 더 유연해지고, 이 함수를 호출하는 쪽에서 더 많은 기능을 사용할 수 있도록 하며 코드 중복도 방지합니다.

```rust
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

### 제네릭 구조체 정의

구조체도 제네릭 타입 매개변수를 사용하여 정의할 수 있습니다.

```rust
struct Point<T> {
    x: T,
    y: T,
}
```

### 제네릭 열거형 정의

열거형도 제네릭 타입 매개변수를 사용하여 정의할 수 있습니다. 예를 들어, Option<T> 열거형은 T 타입에 대한 제네릭이며 Some(T)와 None을 갖습니다.

### 제네릭 메서드 정의

구조체나 열거형에 메서드를 구현할 때도 제네릭 타입을 이용해 정의할 수 있습니다.

```rust
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}
```

### 제네릭 코드의 성능

제네릭 타입 매개변수를 사용하더라도 런타임 비용이 발생하지 않습니다. 러스트는 컴파일 타임에 제네릭을 사용하는 코드를 단형성화하여 특정한 코드로 바꾸는데, 이는 런타임 성능을 저해하지 않고도 제네릭 코드의 장점을 취할 수 있도록 합니다.